/* generated by template generator.InnerComponentWithConstant*/


package visualization.main;

import java.util.LinkedHashMap;
import java.util.Map;
import java.io.IOException;
import de.ma2cfg.simulator.atomic_blocks.Constant;
import de.ma2cfg.simulator.atomic_blocks.Constant;
import de.ma2cfg.simulator.atomic_blocks.Constant;
import de.ma2cfg.simulator.atomic_blocks.Less;
import de.ma2cfg.simulator.atomic_blocks.SwitchB;

import de.se_rwth.commons.logging.Log;

public class ConstantVelocity {
  //inputs
  private Double velocity;
  private Double time;
  
  // outputs
  private Double acceleration;
	
  // internal variables

  // atomic blocks
  private Constant<Double> constant;
  private Constant<Double> constant1;
  private Constant<Double> constant2;
  private Less<Double> relationalOperator;
  private SwitchB<Double> switchBlock;

  // non-atomic blocks

  //connectors
  private Map<String, String> connectors;
  private Map<String, Object> portValues;

  public ConstantVelocity() throws NumberFormatException, IOException {
    this.constant = new Constant<Double>(1.0);
    this.constant1 = new Constant<Double>(0.0);
    this.constant2 = new Constant<Double>(2.0);
    this.relationalOperator = new Less<Double>();
    this.switchBlock = new SwitchB<Double>();

    this.portValues = new LinkedHashMap<String, Object>();

    // connectors map is opposite direction
    // than connectors, b/c reading decadency
    // is opposite than writing dependency
    this.connectors = new LinkedHashMap<String, String>(6);
    connectors.put("acceleration", "switchBlock.out1");
    connectors.put("switchBlock.cond", "relationalOperator.out1");
    connectors.put("switchBlock.in1", "constant2.out1");
    connectors.put("switchBlock.in3", "constant1.out1");
    connectors.put("relationalOperator.in1", "time");
    connectors.put("relationalOperator.in2", "constant.out1");
  }

  public void setInputs(Map<String, Object> inputs) {
    if(!(inputs.get("velocity") == null)) {
      velocity = (Double)Log.errorIfNull(inputs.get("velocity"));
      portValues.put("velocity", velocity);
    }
    if(!(inputs.get("time") == null)) {
      time = (Double)Log.errorIfNull(inputs.get("time"));
      portValues.put("time", time);
    }
  }

   public Map<String, Object> getOutputs() {
     Map<String, Object> outputs = new LinkedHashMap<String, Object>();
     outputs.put("acceleration", acceleration);
     return outputs;
  }

  public void execute(String block) {
    switch(block.substring(0, block.contains(".")?block.indexOf("."):block.length())) {
      // execute constant block
      case "constant":
        Map<String, Object> constantInputs = new LinkedHashMap<String, Object>();
        for(String inport : constant.getInportNames()) {
          constantInputs.put(inport, portValues.get(connectors.get("constant." + inport)));
        }
        constant.setInputs(constantInputs);

        constant.execute();

        Map<String, Object> constantOutputs = constant.getOutputs();
        for(String key : constantOutputs.keySet()) {
          portValues.put("constant."+ key, constantOutputs.get(key));
        }
        break;
      // execute constant1 block
      case "constant1":
        Map<String, Object> constant1Inputs = new LinkedHashMap<String, Object>();
        for(String inport : constant1.getInportNames()) {
          constant1Inputs.put(inport, portValues.get(connectors.get("constant1." + inport)));
        }
        constant1.setInputs(constant1Inputs);

        constant1.execute();

        Map<String, Object> constant1Outputs = constant1.getOutputs();
        for(String key : constant1Outputs.keySet()) {
          portValues.put("constant1."+ key, constant1Outputs.get(key));
        }
        break;
      // execute constant2 block
      case "constant2":
        Map<String, Object> constant2Inputs = new LinkedHashMap<String, Object>();
        for(String inport : constant2.getInportNames()) {
          constant2Inputs.put(inport, portValues.get(connectors.get("constant2." + inport)));
        }
        constant2.setInputs(constant2Inputs);

        constant2.execute();

        Map<String, Object> constant2Outputs = constant2.getOutputs();
        for(String key : constant2Outputs.keySet()) {
          portValues.put("constant2."+ key, constant2Outputs.get(key));
        }
        break;
      // execute relationalOperator block
      case "relationalOperator":
        Map<String, Object> relationalOperatorInputs = new LinkedHashMap<String, Object>();
        for(String inport : relationalOperator.getInportNames()) {
          relationalOperatorInputs.put(inport, portValues.get(connectors.get("relationalOperator." + inport)));
        }
        relationalOperator.setInputs(relationalOperatorInputs);

        relationalOperator.execute();

        Map<String, Object> relationalOperatorOutputs = relationalOperator.getOutputs();
        for(String key : relationalOperatorOutputs.keySet()) {
          portValues.put("relationalOperator."+ key, relationalOperatorOutputs.get(key));
        }
        break;
      // execute switchBlock block
      case "switchBlock":
        Map<String, Object> switchBlockInputs = new LinkedHashMap<String, Object>();
        for(String inport : switchBlock.getInportNames()) {
          switchBlockInputs.put(inport, portValues.get(connectors.get("switchBlock." + inport)));
        }
        switchBlock.setInputs(switchBlockInputs);

        switchBlock.execute();

        Map<String, Object> switchBlockOutputs = switchBlock.getOutputs();
        for(String key : switchBlockOutputs.keySet()) {
          portValues.put("switchBlock."+ key, switchBlockOutputs.get(key));
        }
        break;
      default:
        Log.error("block: " + block + ", is not available in: ConstantVelocity");
        break;
    }
    
    // 2: save output values
    acceleration = (Double)portValues.get(connectors.get("acceleration"));
  }
  
  public static String[] getInportNames() {
  	return new String[] {
      "velocity", 
      "time"
    };
  }
}  