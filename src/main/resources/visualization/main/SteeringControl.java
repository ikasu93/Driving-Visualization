/* generated by template generator.InnerComponentWithConstant*/


package visualization.main;

import java.util.LinkedHashMap;
import java.util.Map;
import java.io.IOException;
import de.ma2cfg.simulator.atomic_blocks.Constant;
import de.ma2cfg.simulator.atomic_blocks.Constant;
import de.ma2cfg.simulator.atomic_blocks.Less;
import de.ma2cfg.simulator.atomic_blocks.Less;
import de.ma2cfg.simulator.atomic_blocks.And;
import de.ma2cfg.simulator.atomic_blocks.SwitchB;

import de.se_rwth.commons.logging.Log;

public class SteeringControl {
  //inputs
  private Double fl;
  private Double fr;
  private Double slf;
  private Double slb;
  
  // outputs
  private Double steering;
	
  // internal variables

  // atomic blocks
  private Constant<Double> steeringValue;
  private Constant<Double> steeringNull;
  private Less<Double> less1;
  private Less<Double> less2;
  private And and;
  private SwitchB<Double> switchB;

  // non-atomic blocks

  //connectors
  private Map<String, String> connectors;
  private Map<String, Object> portValues;

  public SteeringControl() throws NumberFormatException, IOException {
    this.steeringValue = new Constant<Double>(-10.0);
    this.steeringNull = new Constant<Double>(0.0);
    this.less1 = new Less<Double>();
    this.less2 = new Less<Double>();
    this.and = new And();
    this.switchB = new SwitchB<Double>();

    this.portValues = new LinkedHashMap<String, Object>();

    // connectors map is opposite direction
    // than connectors, b/c reading decadency
    // is opposite than writing dependency
    this.connectors = new LinkedHashMap<String, String>(10);
    connectors.put("steering", "switchB.out1");
    connectors.put("less1.in1", "fr");
    connectors.put("less1.in2", "fl");
    connectors.put("less2.in1", "slb");
    connectors.put("less2.in2", "slf");
    connectors.put("and.in1", "less1.out1");
    connectors.put("and.in2", "less2.out1");
    connectors.put("switchB.cond", "and.out1");
    connectors.put("switchB.in1", "steeringValue.out1");
    connectors.put("switchB.in3", "steeringNull.out1");
  }

  public void setInputs(Map<String, Object> inputs) {
    if(!(inputs.get("fl") == null)) {
      fl = (Double)Log.errorIfNull(inputs.get("fl"));
      portValues.put("fl", fl);
    }
    if(!(inputs.get("fr") == null)) {
      fr = (Double)Log.errorIfNull(inputs.get("fr"));
      portValues.put("fr", fr);
    }
    if(!(inputs.get("slf") == null)) {
      slf = (Double)Log.errorIfNull(inputs.get("slf"));
      portValues.put("slf", slf);
    }
    if(!(inputs.get("slb") == null)) {
      slb = (Double)Log.errorIfNull(inputs.get("slb"));
      portValues.put("slb", slb);
    }
  }

   public Map<String, Object> getOutputs() {
     Map<String, Object> outputs = new LinkedHashMap<String, Object>();
     outputs.put("steering", steering);
     return outputs;
  }

  public void execute(String block) {
    switch(block.substring(0, block.contains(".")?block.indexOf("."):block.length())) {
      // execute steeringValue block
      case "steeringValue":
        Map<String, Object> steeringValueInputs = new LinkedHashMap<String, Object>();
        for(String inport : steeringValue.getInportNames()) {
          steeringValueInputs.put(inport, portValues.get(connectors.get("steeringValue." + inport)));
        }
        steeringValue.setInputs(steeringValueInputs);

        steeringValue.execute();

        Map<String, Object> steeringValueOutputs = steeringValue.getOutputs();
        for(String key : steeringValueOutputs.keySet()) {
          portValues.put("steeringValue."+ key, steeringValueOutputs.get(key));
        }
        break;
      // execute steeringNull block
      case "steeringNull":
        Map<String, Object> steeringNullInputs = new LinkedHashMap<String, Object>();
        for(String inport : steeringNull.getInportNames()) {
          steeringNullInputs.put(inport, portValues.get(connectors.get("steeringNull." + inport)));
        }
        steeringNull.setInputs(steeringNullInputs);

        steeringNull.execute();

        Map<String, Object> steeringNullOutputs = steeringNull.getOutputs();
        for(String key : steeringNullOutputs.keySet()) {
          portValues.put("steeringNull."+ key, steeringNullOutputs.get(key));
        }
        break;
      // execute less1 block
      case "less1":
        Map<String, Object> less1Inputs = new LinkedHashMap<String, Object>();
        for(String inport : less1.getInportNames()) {
          less1Inputs.put(inport, portValues.get(connectors.get("less1." + inport)));
        }
        less1.setInputs(less1Inputs);

        less1.execute();

        Map<String, Object> less1Outputs = less1.getOutputs();
        for(String key : less1Outputs.keySet()) {
          portValues.put("less1."+ key, less1Outputs.get(key));
        }
        break;
      // execute less2 block
      case "less2":
        Map<String, Object> less2Inputs = new LinkedHashMap<String, Object>();
        for(String inport : less2.getInportNames()) {
          less2Inputs.put(inport, portValues.get(connectors.get("less2." + inport)));
        }
        less2.setInputs(less2Inputs);

        less2.execute();

        Map<String, Object> less2Outputs = less2.getOutputs();
        for(String key : less2Outputs.keySet()) {
          portValues.put("less2."+ key, less2Outputs.get(key));
        }
        break;
      // execute and block
      case "and":
        Map<String, Object> andInputs = new LinkedHashMap<String, Object>();
        for(String inport : and.getInportNames()) {
          andInputs.put(inport, portValues.get(connectors.get("and." + inport)));
        }
        and.setInputs(andInputs);

        and.execute();

        Map<String, Object> andOutputs = and.getOutputs();
        for(String key : andOutputs.keySet()) {
          portValues.put("and."+ key, andOutputs.get(key));
        }
        break;
      // execute switchB block
      case "switchB":
        Map<String, Object> switchBInputs = new LinkedHashMap<String, Object>();
        for(String inport : switchB.getInportNames()) {
          switchBInputs.put(inport, portValues.get(connectors.get("switchB." + inport)));
        }
        switchB.setInputs(switchBInputs);

        switchB.execute();

        Map<String, Object> switchBOutputs = switchB.getOutputs();
        for(String key : switchBOutputs.keySet()) {
          portValues.put("switchB."+ key, switchBOutputs.get(key));
        }
        break;
      default:
        Log.error("block: " + block + ", is not available in: SteeringControl");
        break;
    }
    
    // 2: save output values
    steering = (Double)portValues.get(connectors.get("steering"));
  }
  
  public static String[] getInportNames() {
  	return new String[] {
      "fl", 
      "fr", 
      "slf", 
      "slb"
    };
  }
}  