/* generated by template generator.InnerComponentWithConstant*/


package visualization.main;

import java.util.LinkedHashMap;
import java.util.Map;
import java.io.IOException;
import de.ma2cfg.simulator.atomic_blocks.Constant;
import de.ma2cfg.simulator.atomic_blocks.Constant;
import de.ma2cfg.simulator.atomic_blocks.Mod;
import de.ma2cfg.simulator.atomic_blocks.Less;

import de.se_rwth.commons.logging.Log;

public class IndicatorStatus {
  //inputs
  private Double time;
  
  // outputs
  private Boolean status;
	
  // internal variables

  // atomic blocks
  private Constant<Double> divisor;
  private Constant<Double> condition;
  private Mod<Double> mod;
  private Less<Double> less;

  // non-atomic blocks

  //connectors
  private Map<String, String> connectors;
  private Map<String, Object> portValues;

  public IndicatorStatus() throws NumberFormatException, IOException {
    this.divisor = new Constant<Double>(2.0);
    this.condition = new Constant<Double>(1.0);
    this.mod = new Mod<Double>();
    this.less = new Less<Double>();

    this.portValues = new LinkedHashMap<String, Object>();

    // connectors map is opposite direction
    // than connectors, b/c reading decadency
    // is opposite than writing dependency
    this.connectors = new LinkedHashMap<String, String>(5);
    connectors.put("status", "less.out1");
    connectors.put("mod.in1", "time");
    connectors.put("mod.in2", "divisor.out1");
    connectors.put("less.in1", "mod.out1");
    connectors.put("less.in2", "condition.out1");
  }

  public void setInputs(Map<String, Object> inputs) {
    if(!(inputs.get("time") == null)) {
      time = (Double)Log.errorIfNull(inputs.get("time"));
      portValues.put("time", time);
    }
  }

   public Map<String, Object> getOutputs() {
     Map<String, Object> outputs = new LinkedHashMap<String, Object>();
     outputs.put("status", status);
     return outputs;
  }

  public void execute(String block) {
    switch(block.substring(0, block.contains(".")?block.indexOf("."):block.length())) {
      // execute divisor block
      case "divisor":
        Map<String, Object> divisorInputs = new LinkedHashMap<String, Object>();
        for(String inport : divisor.getInportNames()) {
          divisorInputs.put(inport, portValues.get(connectors.get("divisor." + inport)));
        }
        divisor.setInputs(divisorInputs);

        divisor.execute();

        Map<String, Object> divisorOutputs = divisor.getOutputs();
        for(String key : divisorOutputs.keySet()) {
          portValues.put("divisor."+ key, divisorOutputs.get(key));
        }
        break;
      // execute condition block
      case "condition":
        Map<String, Object> conditionInputs = new LinkedHashMap<String, Object>();
        for(String inport : condition.getInportNames()) {
          conditionInputs.put(inport, portValues.get(connectors.get("condition." + inport)));
        }
        condition.setInputs(conditionInputs);

        condition.execute();

        Map<String, Object> conditionOutputs = condition.getOutputs();
        for(String key : conditionOutputs.keySet()) {
          portValues.put("condition."+ key, conditionOutputs.get(key));
        }
        break;
      // execute mod block
      case "mod":
        Map<String, Object> modInputs = new LinkedHashMap<String, Object>();
        for(String inport : mod.getInportNames()) {
          modInputs.put(inport, portValues.get(connectors.get("mod." + inport)));
        }
        mod.setInputs(modInputs);

        mod.execute();

        Map<String, Object> modOutputs = mod.getOutputs();
        for(String key : modOutputs.keySet()) {
          portValues.put("mod."+ key, modOutputs.get(key));
        }
        break;
      // execute less block
      case "less":
        Map<String, Object> lessInputs = new LinkedHashMap<String, Object>();
        for(String inport : less.getInportNames()) {
          lessInputs.put(inport, portValues.get(connectors.get("less." + inport)));
        }
        less.setInputs(lessInputs);

        less.execute();

        Map<String, Object> lessOutputs = less.getOutputs();
        for(String key : lessOutputs.keySet()) {
          portValues.put("less."+ key, lessOutputs.get(key));
        }
        break;
      default:
        Log.error("block: " + block + ", is not available in: IndicatorStatus");
        break;
    }
    
    // 2: save output values
    status = (Boolean)portValues.get(connectors.get("status"));
  }
  
  public static String[] getInportNames() {
  	return new String[] {
      "time"
    };
  }
}  