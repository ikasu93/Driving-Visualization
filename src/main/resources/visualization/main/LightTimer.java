/* generated by template generator.InnerComponentWithConstant*/


package visualization.main;

import java.util.LinkedHashMap;
import java.util.Map;
import java.io.IOException;
import de.ma2cfg.simulator.atomic_blocks.Constant;
import de.ma2cfg.simulator.atomic_blocks.Greater;

import de.se_rwth.commons.logging.Log;

public class LightTimer {
  //inputs
  private Double time;
  
  // outputs
  private Boolean status;
	
  // internal variables

  // atomic blocks
  private Constant<Double> timeout;
  private Greater<Double> greater;

  // non-atomic blocks

  //connectors
  private Map<String, String> connectors;
  private Map<String, Object> portValues;

  public LightTimer() throws NumberFormatException, IOException {
    this.timeout = new Constant<Double>(1.0);
    this.greater = new Greater<Double>();

    this.portValues = new LinkedHashMap<String, Object>();

    // connectors map is opposite direction
    // than connectors, b/c reading decadency
    // is opposite than writing dependency
    this.connectors = new LinkedHashMap<String, String>(3);
    connectors.put("status", "greater.out1");
    connectors.put("greater.in1", "time");
    connectors.put("greater.in2", "timeout.out1");
  }

  public void setInputs(Map<String, Object> inputs) {
    if(!(inputs.get("time") == null)) {
      time = (Double)Log.errorIfNull(inputs.get("time"));
      portValues.put("time", time);
    }
  }

   public Map<String, Object> getOutputs() {
     Map<String, Object> outputs = new LinkedHashMap<String, Object>();
     outputs.put("status", status);
     return outputs;
  }

  public void execute(String block) {
    switch(block.substring(0, block.contains(".")?block.indexOf("."):block.length())) {
      // execute timeout block
      case "timeout":
        Map<String, Object> timeoutInputs = new LinkedHashMap<String, Object>();
        for(String inport : timeout.getInportNames()) {
          timeoutInputs.put(inport, portValues.get(connectors.get("timeout." + inport)));
        }
        timeout.setInputs(timeoutInputs);

        timeout.execute();

        Map<String, Object> timeoutOutputs = timeout.getOutputs();
        for(String key : timeoutOutputs.keySet()) {
          portValues.put("timeout."+ key, timeoutOutputs.get(key));
        }
        break;
      // execute greater block
      case "greater":
        Map<String, Object> greaterInputs = new LinkedHashMap<String, Object>();
        for(String inport : greater.getInportNames()) {
          greaterInputs.put(inport, portValues.get(connectors.get("greater." + inport)));
        }
        greater.setInputs(greaterInputs);

        greater.execute();

        Map<String, Object> greaterOutputs = greater.getOutputs();
        for(String key : greaterOutputs.keySet()) {
          portValues.put("greater."+ key, greaterOutputs.get(key));
        }
        break;
      default:
        Log.error("block: " + block + ", is not available in: LightTimer");
        break;
    }
    
    // 2: save output values
    status = (Boolean)portValues.get(connectors.get("status"));
  }
  
  public static String[] getInportNames() {
  	return new String[] {
      "time"
    };
  }
}  